<?
import java.lang.reflect.Method;
import java.math.RoundingMode;

import com.sun.source.tree.*;
import com.sun.source.tree.Tree.Kind;
import com.sun.source.util.TreePath;
import com.sun.tools.javac.tree.*;
?>

// 9
$class.newInstance() :: $class instanceof Class =>
$class.getDeclaredConstructor().newInstance()
;;

// 7
$f.toURL() :: $f instanceof java.io.File =>
$f.toURI().toURL()
;;

// avoid Hashtable methods since doc requires Strings in Properties
// putting Objects into it could lead to bugs
$props.put($key, $value) :: $props instanceof java.util.Properties =>
$props.setProperty($key, $value)
;;

$props.get($key) :: $props instanceof java.util.Properties =>
$props.getProperty($key)
;;

// JFrame methods deprecated in 5
$f.show($b$) :: $f instanceof javax.swing.JFrame =>
$f.setVisible($b$);
;;

$f.hide() :: $f instanceof javax.swing.JFrame =>
$f.setVisible(false);
;;

// deprecated in 10
Runtime.version().major() =>
Runtime.version().feature()
;;

Runtime.version().minor() =>
Runtime.version().interim()
;;

Runtime.version().security() =>
Runtime.version().update()
;;

// TODO: import RoundingMode somehow

// BigDecimal method deprecations in 9 -> RoundingMode enum
$bd.setScale($s, $mode) :: $bd instanceof java.math.BigDecimal && $s instanceof int && $mode instanceof int =>
$bd.setScale($s, $enum) :: flag2Enum($mode, $enum)
;;

$bd.divide($bd2, $mode) :: $bd instanceof java.math.BigDecimal && $bd2 instanceof java.math.BigDecimal && $mode instanceof int =>
$bd.divide($bd2, $enum) :: flag2Enum($mode, $enum)
;;

$bd.divide($bd2, $s, $mode) :: $bd instanceof java.math.BigDecimal && $bd2 instanceof java.math.BigDecimal && $s instanceof int && $mode instanceof int =>
$bd.divide($bd2, $s, $enum) :: flag2Enum($mode, $enum)
;;


// since 16
jdk.net.Sockets.getOption($socket, $opt) :: $socket instanceof java.net.DatagramSocket && $opt instanceof java.net.SocketOption =>
$socket.getOption($opt)
;;

jdk.net.Sockets.getOption($socket, $opt) :: $socket instanceof java.net.ServerSocket && $opt instanceof java.net.SocketOption =>
$socket.getOption($opt)
;;

jdk.net.Sockets.getOption($socket, $opt) :: $socket instanceof java.net.Socket && $opt instanceof java.net.SocketOption =>
$socket.getOption($opt)
;;


jdk.net.Sockets.setOption($socket, $opt, $v) :: $socket instanceof java.net.DatagramSocket && $opt instanceof java.net.SocketOption =>
$socket.setOption($opt, $v)
;;

jdk.net.Sockets.setOption($socket, $opt, $v) :: $socket instanceof java.net.ServerSocket && $opt instanceof java.net.SocketOption =>
$socket.setOption($opt, $v)
;;

jdk.net.Sockets.setOption($socket, $opt, $v) :: $socket instanceof java.net.Socket && $opt instanceof java.net.SocketOption =>
$socket.setOption($opt, $v)
;;


// since 14
$socket.getLoopbackMode() :: $socket instanceof java.net.MulticastSocket =>
$socket.getOption(java.net.StandardSocketOptions.IP_MULTICAST_LOOP)
;;

$socket.setLoopbackMode($b):: $socket instanceof java.net.MulticastSocket && $b instanceof boolean =>
$socket.setOption(java.net.StandardSocketOptions.IP_MULTICAST_LOOP, $b)
;;



// since 17

// todo: doesn't work, body is not captured
/*
java.security.AccessController.doPrivileged(new java.security.PrivilegedAction<Void>() {

    public Void run() {
        $body$;
        return null;
    }
});
=>
$body$;
;;
*/

<?
public boolean flag2Enum(Variable str, Variable target) throws Throwable {
    
    RoundingMode mode = getMatchingEnum(str);

    String value = "RoundingMode." + (mode != null ? mode.name() : "/*TODO*/");

    context.createRenamed(str, target, value);
    return true;
}
private RoundingMode getMatchingEnum(Variable str) throws Throwable {

    Method m = context.getClass().getDeclaredMethod("getSingleVariable", Variable.class);
    m.setAccessible(true);
    TreePath tp = (TreePath) m.invoke(context, str);

    if (tp.getLeaf().getKind() == Kind.INT_LITERAL) {
        try {
            return RoundingMode.valueOf(Integer.parseInt(tp.getLeaf().toString()));
        } catch (NumberFormatException ex) {
            return null;
        }
    } else if (tp.getLeaf() instanceof JCTree.JCExpression) { // TODO there is probably a way how to get values of constants
        String exp = ((JCTree.JCExpression)tp.getLeaf()).toString();

        int dot = exp.lastIndexOf('.');
        if (dot != -1) {
            exp = exp.substring(dot+1);
        }
        
        if (exp.startsWith("ROUND_")) {
            exp = exp.substring(6);
        }

        try {
            return RoundingMode.valueOf(exp.toUpperCase());
        } catch (IllegalArgumentException ex) {
            return null;
        }

    }
    return null;
}
?>
