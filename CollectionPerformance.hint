
<!description="Refactor to modern Collection APIs and idioms.">

// replace old collections
java.util.Stack =>
java.util.ArrayDeque;;

java.util.Vector =>
java.util.ArrayList;;
/*
java.util.LinkedList =>
java.util.ArrayList;;
*/
java.util.Hashtable =>
java.util.HashMap;;

$modifiers$ java.util.Stack<$g> $name = new java.util.Stack<$g$>(); =>
$modifiers$ java.util.Deque<$g> $name = new java.util.ArrayDeque<$g$>();
;;

/*
$modifiers$ java.util.Stack<$g> $name = $initializer; =>
$modifiers$ java.util.Deque<$g> $name = $initializer;
;;

$modifiers$ java.util.Stack<$g> $name; =>
$modifiers$ java.util.Deque<$g> $name;
;;

new java.util.Stack<$g$>() =>
new java.util.Deque<$g$>()
;;
*/

// maps to Collection interface post refactoring
$stack.empty() :: $stack instanceof java.util.Stack =>
$stack.isEmpty()
;;

// avoid raw type warnings
java.util.Collections.EMPTY_LIST =>
java.util.Collections.emptyList();;

java.util.Collections.EMPTY_SET =>
java.util.Collections.emptySet();;

java.util.Collections.EMPTY_MAP =>
java.util.Collections.emptyMap();;

// more descriptive
java.util.Arrays.asList() =>
java.util.Collections.emptyList();;

// prefer immutable collection for small arrays
// not recommended for large arrays in inner loops due to the null check
// todo: add check for $a not being an array + remove $b
java.util.Arrays.asList($a, $b, $more$) :: !parentMatches("java.util.Collections.unmodifiableList($_)") && sourceVersionGE(9) =>
java.util.List.of($a, $b, $more$);;

// shorter 9+
java.util.Collections.singletonList($a) :: sourceVersionGE(9) =>
java.util.List.of($a);;

java.util.Collections.singleton($a) :: sourceVersionGE(9) =>
java.util.Set.of($a);;

java.util.Collections.singletonMap($k, $v) :: sourceVersionGE(9) =>
java.util.Map.of($k, $v);;

// 9+
java.util.Collections.unmodifiableList(java.util.Arrays.asList($a$)) :: sourceVersionGE(9) =>
java.util.List.of($a$);;

java.util.Collections.unmodifiableList(java.util.List.of($a$)) :: sourceVersionGE(9) =>
java.util.List.of($a$);;

java.util.Collections.unmodifiableSet(java.util.Set.of($a$)) :: sourceVersionGE(9) =>
java.util.Set.of($a$);;

java.util.Collections.unmodifiableSet(new $Set<$T$>(java.util.Arrays.asList($a$))) :: $Set instanceof java.util.Set && sourceVersionGE(9) =>
java.util.Set.of($a$);;

java.util.Collections.unmodifiableSet(new $Set<$T$>(java.util.List.of($a$))) :: $Set instanceof java.util.Set && sourceVersionGE(9) =>
java.util.Set.of($a$);;

// todo: needs read only check
"could be potentially replaced with Set.of(..) - if immutable.":
new $Set<$T$>(java.util.Arrays.asList($a, $b, $more$)) :: $Set instanceof java.util.Set && !parentMatches("java.util.Collections.unmodifiableSet($_)") && sourceVersionGE(9) =>
java.util.Set.of($a, $b, $more$)
;;

"could be potentially replaced with Set.of(..) - if immutable.":
new $Set<$T$>(java.util.List.of($a, $b, $more$)) :: $Set instanceof java.util.Set && !parentMatches("java.util.Collections.unmodifiableSet($_)") && sourceVersionGE(9) =>
java.util.Set.of($a, $b, $more$)
;;

// unmodifiable view -> immutable copy; 10+
/*
"unmodifiable view can be potentially replaced with immutable copy.":
java.util.Collections.unmodifiableList($list) :: $list instanceof java.util.List && sourceVersionGE(10) =>
java.util.List.copyOf($list);;

"unmodifiable view can be potentially replaced with immutable copy.":
java.util.Collections.unmodifiableCollection($col) :: $col instanceof java.util.Collection && sourceVersionGE(10) =>
java.util.List.copyOf($col);;

"unmodifiable view can be potentially replaced with immutable copy.":
java.util.Collections.unmodifiableSet($set) :: $set instanceof java.util.Set && sourceVersionGE(10) =>
java.util.Set.copyOf($set);;

"unmodifiable view can be potentially replaced with immutable copy.":
java.util.Collections.unmodifiableMap($map) :: $map instanceof java.util.Map && sourceVersionGE(10) =>
java.util.Map.copyOf($map);;
*/

// prefer list.sort()
// less readable
//java.util.Collections.sort($list) :: $list instanceof java.util.List =>
//$list.sort(null);;

java.util.Collections.sort($list, $comp) :: $list instanceof java.util.List =>
$list.sort($comp);;

// collections have faster bulk add opperations than the sequential loop of Collections.addAll()
java.util.Collections.addAll($col, $array$) :: $col instanceof java.util.Collection =>
$col.addAll(java.util.Arrays.asList($array$));;


// prefer copy constructor over addAll()
$more$ $col = new $Col();
$col.addAll($other); :: $Col instanceof java.util.Collection =>
$more$ $col = new $Col($other);
;;

$more$ $map = new $Map();
$map.putAll($other); :: $Map instanceof java.util.Map =>
$more$ $map = new $Map($other);
;;

// avoid inefficient map traversal
for ($K $k : $map.keySet()) {
    $preamble$;
    $V $v = $map.get($k);
    $body$;
} :: $map instanceof java.util.Map && !referencedIn($k, $preamble$)
=>
for ($V $v : $map.values()) {
    $preamble$;
    $body$;
}
:: !referencedIn($k, $body$)
=>
for (java.util.Map.Entry<$K, $V> entry : $map.entrySet()) {
    $preamble$;
    $K $k = entry.getKey();
    $V $v = entry.getValue();
    $body$;
}
:: otherwise
;;

// contains + get in succession
"could be potentially replaced with a single get(key) if the map does not contain null values":
if ($map.containsKey($key)) {
    $preamble$;
    $V $v = $map.get($key);
    $body$;
} :: $map instanceof java.util.Map && !referencedIn($key, $preamble$)
=>
$V $v = $map.get($key);
if ($v != null) {
    $preamble$;
    $body$;
}
;;

// todo: figure out how to get val type
"could be potentially replaced with a single get(key) if the map does not contain null values":
if ($map.containsKey($key)) {
    return $map.get($key);
} :: $map instanceof java.util.Map
=>
Object val = $map.get($key);
if (val != null) {
    return val;
}
;;

// contains + remove in succession
if ($col.contains($v)) {
    $col.remove($v);
} :: $col instanceof java.util.Collection
=>
$col.remove($v);
;;

if ($map.containsKey($k)) {
    $map.remove($k);
    $rest$;
} :: $map instanceof java.util.Map
=>
$map.remove($k);
:: isEmpty($rest$)
=>
"could be potentially replaced with a single remove(key) if the map does not contain null values":
if ($map.remove($k) == null) {
    $rest$;
}
:: otherwise
;;

// contains + put
"could be potentially replaced with putIfAbsent(key, value) if the map does not contain null values":
if (!$map.containsKey($k)) {
    $map.put($k, $v);
} :: $map instanceof java.util.Map
=>
$map.putIfAbsent($k, $v);
;;

// get instead contains (dangerous! values can be null)
/*
$map.get($k) == null :: $map instanceof java.util.Map =>
!$map.containsKey($k)
;;

$map.get($k) != null :: $map instanceof java.util.Map =>
$map.containsKey($k)
;;
*/

// concise map population
for ($O $o : $col) {
    $map.put($key, $value);
} :: $col instanceof java.util.Collection && $map instanceof java.util.Map
=>
$col.forEach($o -> $map.put($key, $value));
;;


// removeIf() 8+
java.util.Iterator<$T> $it = $col.iterator();
while ($it.hasNext()) {
    $T $t = $it.next();
    if ($condition) {
        $it.remove();
    }
} :: $col instanceof java.util.Collection
=>
$col.removeIf($t -> $condition);
;;

// this one gonna be tricky
/*
java.util.Iterator<$T> $it = $col.iterator();
while ($it.hasNext()) {
    if ($it.next().$foo() {
        $it.remove();
    }
} :: $col instanceof java.util.Collection
=>
$col.removeIf($T::$foo)
;;
*/

for (java.util.Iterator<$T> $it = $col.iterator(); $it.hasNext(); ) {
    $T $t = $it.next();
    if ($condition) {
        $it.remove();
    }
} :: $col instanceof java.util.Collection
=>
$col.removeIf($t -> $condition);
;;


// URLs as keys can caue performance problems
// set + URL
"URLs used as keys in collections can cause performance problems, since equals() and hashCode() trigger blocking domain lookup operations. Try using java.net.URI instead.":
new $SET<java.net.URL>($args$) :: $SET instanceof java.util.Set =>
new $SET<java.net.URI>($args$)
;;

"URLs used as keys in collections can cause performance problems, since equals() and hashCode() trigger blocking domain lookup operations. Try using java.net.URI instead.":
$SET<java.net.URL> $set = $init$; :: $set instanceof java.util.Set =>
$SET<java.net.URI> $set = $init$;
;;

"URLs used as keys in collections can cause performance problems, since equals() and hashCode() trigger blocking domain lookup operations. Try using java.net.URI instead.":
$set.add($key) :: $set instanceof java.util.Set<java.net.URL> && $key instanceof java.net.URL =>
$set.add($key.toURI())
;;

// map + URL
"URLs used as keys in collections can cause performance problems, since equals() and hashCode() trigger blocking domain lookup operations. Try using java.net.URI instead.":
new $MAP<java.net.URL, $V>($args$) :: $MAP instanceof java.util.Map =>
new $MAP<java.net.URI, $V>($args$)
;;

"URLs used as keys in collections can cause performance problems, since equals() and hashCode() trigger blocking domain lookup operations. Try using java.net.URI instead.":
$MAP<java.net.URL, $V> $map = $init$; :: $MAP instanceof java.util.Map =>
$MAP<java.net.URI, $V> $map = $init$;
;;

"URLs used as keys in collections can cause performance problems, since equals() and hashCode() trigger blocking domain lookup operations. Try using java.net.URI instead.":
$map.put($key, $value) :: $map instanceof java.util.Map<java.net.URL, ?> && $key instanceof java.net.URL =>
$map.put($key.toURI(), $value)
;;


<?
    public boolean isEmpty(Variable var) throws Throwable {
        return !context.getIndexedVariables(var).iterator().hasNext();
    }

?>

