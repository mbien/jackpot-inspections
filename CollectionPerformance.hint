<?
import org.netbeans.modules.java.hints.declarative.APIAccessor;
import com.sun.source.tree.*;
import com.sun.source.tree.Tree.Kind;
import com.sun.source.util.TreePath;
import com.sun.tools.javac.tree.*;
?>

<!description="Refactor to modern Collection APIs and idioms.">

// replace old collections
java.util.Stack =>
java.util.ArrayDeque;;

java.util.Vector =>
java.util.ArrayList;;
/*
java.util.LinkedList =>
java.util.ArrayList;;
*/
java.util.Hashtable =>
java.util.HashMap;;

$modifiers$ java.util.Stack<$g> $name = new java.util.Stack<$g$>(); =>
$modifiers$ java.util.Deque<$g> $name = new java.util.ArrayDeque<$g$>();
;;

/*
$modifiers$ java.util.Stack<$g> $name = $initializer; =>
$modifiers$ java.util.Deque<$g> $name = $initializer;
;;

$modifiers$ java.util.Stack<$g> $name; =>
$modifiers$ java.util.Deque<$g> $name;
;;

new java.util.Stack<$g$>() =>
new java.util.Deque<$g$>()
;;
*/

// maps to Collection interface post refactoring
$stack.empty() :: $stack instanceof java.util.Stack =>
$stack.isEmpty()
;;

// avoid raw type warnings
java.util.Collections.EMPTY_LIST =>
java.util.Collections.emptyList();;

java.util.Collections.EMPTY_SET =>
java.util.Collections.emptySet();;

java.util.Collections.EMPTY_MAP =>
java.util.Collections.emptyMap();;

// more descriptive
java.util.Arrays.asList() =>
java.util.Collections.emptyList();;

// prefer immutable collection for small arrays
// not recommended for large arrays in inner loops due to the null check
// todo: add check for $a not being an array + remove $b
"List.of is more compact for small lists.":
java.util.Arrays.asList($a, $b, $more$) :: !parentMatches("java.util.Collections.unmodifiableList($_)") && sourceVersionGE(9) =>
java.util.List.of($a, $b, $more$);;

// shorter 9+
java.util.Collections.singletonList($a) :: sourceVersionGE(9) =>
java.util.List.of($a);;

java.util.Collections.singleton($a) :: sourceVersionGE(9) =>
java.util.Set.of($a);;

java.util.Collections.singletonMap($k, $v) :: sourceVersionGE(9) =>
java.util.Map.of($k, $v);;

// 9+
java.util.Collections.unmodifiableList(java.util.Arrays.asList($a$)) :: sourceVersionGE(9) =>
java.util.List.of($a$);;

java.util.Collections.unmodifiableList(java.util.List.of($a$)) :: sourceVersionGE(9) =>
java.util.List.of($a$);;

java.util.Collections.unmodifiableSet(java.util.Set.of($a$)) :: sourceVersionGE(9) =>
java.util.Set.of($a$);;

java.util.Collections.unmodifiableSet(new $Set<$T$>(java.util.Arrays.asList($a$))) :: $Set instanceof java.util.Set && sourceVersionGE(9) =>
java.util.Set.of($a$);;

java.util.Collections.unmodifiableSet(new $Set<$T$>(java.util.List.of($a$))) :: $Set instanceof java.util.Set && sourceVersionGE(9) =>
java.util.Set.of($a$);;

java.util.Collections.newSetFromMap(new java.util.LinkedHashMap<$kv$>()) =>
new java.util.LinkedHashSet<>();;

// todo: needs read only check
"could be potentially replaced with Set.of(..) - if immutable.":
new $Set<$T$>(java.util.Arrays.asList($a, $b, $more$)) :: $Set instanceof java.util.Set && !parentMatches("java.util.Collections.unmodifiableSet($_)") && sourceVersionGE(9) =>
java.util.Set.of($a, $b, $more$)
;;

"could be potentially replaced with Set.of(..) - if immutable.":
new $Set<$T$>(java.util.List.of($a, $b, $more$)) :: $Set instanceof java.util.Set && !parentMatches("java.util.Collections.unmodifiableSet($_)") && sourceVersionGE(9) =>
java.util.Set.of($a, $b, $more$)
;;

// unmodifiable view -> immutable copy; 10+
/*
"unmodifiable view can be potentially replaced with immutable copy.":
java.util.Collections.unmodifiableList($list) :: $list instanceof java.util.List && sourceVersionGE(10) =>
java.util.List.copyOf($list);;

"unmodifiable view can be potentially replaced with immutable copy.":
java.util.Collections.unmodifiableCollection($col) :: $col instanceof java.util.Collection && sourceVersionGE(10) =>
java.util.List.copyOf($col);;

"unmodifiable view can be potentially replaced with immutable copy.":
java.util.Collections.unmodifiableSet($set) :: $set instanceof java.util.Set && sourceVersionGE(10) =>
java.util.Set.copyOf($set);;

"unmodifiable view can be potentially replaced with immutable copy.":
java.util.Collections.unmodifiableMap($map) :: $map instanceof java.util.Map && sourceVersionGE(10) =>
java.util.Map.copyOf($map);;
*/

// prefer list.sort()
// less readable
//java.util.Collections.sort($list) :: $list instanceof java.util.List =>
//$list.sort(null);;

java.util.Collections.sort($list, $comp) :: $list instanceof java.util.List =>
$list.sort($comp);;

// collections have faster bulk add opperations than the sequential loop of Collections.addAll()
java.util.Collections.addAll($col, $array$) :: $col instanceof java.util.Collection =>
$col.addAll(java.util.Arrays.asList($array$));;


// prefer copy constructor over addAll()
$more$ $col = new $Col();
$col.addAll($other); :: $Col instanceof java.util.Collection =>
$more$ $col = new $Col($other);
;;

$more$ $map = new $Map();
$map.putAll($other); :: $Map instanceof java.util.Map =>
$more$ $map = new $Map($other);
;;

// avoid inefficient map traversal
for ($K $k : $map.keySet()) {
    $preamble$;
    $V $v = $map.get($k);
    $body$;
} :: $map instanceof java.util.Map && !referencedIn($k, $preamble$)
=>
for ($V $v : $map.values()) {
    $preamble$;
    $body$;
}
:: !referencedIn($k, $body$)
=>
for (java.util.Map.Entry<$K, $V> entry : $map.entrySet()) {
    $preamble$;
    $K $k = entry.getKey();
    $V $v = entry.getValue();
    $body$;
}
:: otherwise
;;

// contains + get in succession
"could be potentially replaced with a single get(key) if the map does not contain null values":
if ($map.containsKey($key)) {
    $preamble$;
    $V $v = $map.get($key);
    $body$;
} :: $map instanceof java.util.Map && !referencedIn($key, $preamble$)
=>
$V $v = $map.get($key);
if ($v != null) {
    $preamble$;
    $body$;
}
;;

// todo: figure out how to get val type
"could be potentially replaced with a single get(key) if the map does not contain null values":
if ($map.containsKey($key)) {
    return $map.get($key);
} :: $map instanceof java.util.Map
=>
Object val = $map.get($key);
if (val != null) {
    return val;
}
;;

// get + remove in succession
if ($map.get($k) == $v) {
    $map.remove($k);
} :: $map instanceof java.util.Map
=>
$map.remove($k, $v);
;;

// contains + remove in succession
if ($col.contains($v)) {
    $col.remove($v);
} :: $col instanceof java.util.Collection
=>
$col.remove($v);
;;

if ($map.containsKey($k)) {
    $map.remove($k);
    $rest$;
} :: $map instanceof java.util.Map
=>
$map.remove($k);
:: isEmpty($rest$)
=>
"could be potentially replaced with a single remove(key) if the map does not contain null values":
if ($map.remove($k) == null) {
    $rest$;
}
:: otherwise
;;

// contains + put
"could be potentially replaced with putIfAbsent(key, value) if the map does not contain null values":
if (!$map.containsKey($k)) {
    $map.put($k, $v);
} :: $map instanceof java.util.Map
=>
$map.putIfAbsent($k, $v);
;;

// add to sub-collection
"could be replaced with putIfAbsent(key, new SubCollection()).add(toAdd)":
$Col $subcol = $map.get($key);
if ($subcol == null) {
    $subcol = $subColInit;
    $map.put($key, $subcol);
}
$statement;                                     :: $map instanceof java.util.Map && $subcol instanceof java.util.Collection
=>
$map.putIfAbsent($key, $subColInit).add($item); :: matchesWithBind($statement, "$subcol.add($item);")
=>
$Col $subcol = $map.putIfAbsent($key, $subColInit);
$statement;                                     :: otherwise
;;

// get instead contains (dangerous! values can be null)
/*
$map.get($k) == null :: $map instanceof java.util.Map =>
!$map.containsKey($k)
;;

$map.get($k) != null :: $map instanceof java.util.Map =>
$map.containsKey($k)
;;
*/

// concise map population
for ($O $o : $col) {
    $map.put($key, $value);
} :: $col instanceof java.util.Collection && $map instanceof java.util.Map
=>
$col.forEach($o -> $map.put($key, $value));
;;


// removeIf() 8+
java.util.Iterator<$T> $it = $col.iterator();
while ($it.hasNext()) {
    $T $t = $it.next();
    if ($condition) {
        $it.remove();
    }
} :: $col instanceof java.util.Collection
=>
$col.removeIf($t -> $condition);
;;

// this one gonna be tricky
/*
java.util.Iterator<$T> $it = $col.iterator();
while ($it.hasNext()) {
    if ($it.next().$foo() {
        $it.remove();
    }
} :: $col instanceof java.util.Collection
=>
$col.removeIf($T::$foo)
;;
*/

for (java.util.Iterator<$T> $it = $col.iterator(); $it.hasNext(); ) {
    $T $t = $it.next();
    if ($condition) {
        $it.remove();
    }
} :: $col instanceof java.util.Collection
=>
$col.removeIf($t -> $condition);
;;


// URLs as keys can caue performance problems
// set + URL
"URLs used as keys in collections can cause performance problems, since equals() and hashCode() trigger blocking domain lookup operations. Try using java.net.URI instead.":
new $SET<java.net.URL>($args$) :: $SET instanceof java.util.Set =>
new $SET<java.net.URI>($args$)
;;

"URLs used as keys in collections can cause performance problems, since equals() and hashCode() trigger blocking domain lookup operations. Try using java.net.URI instead.":
$SET<java.net.URL> $set = $init$; :: $set instanceof java.util.Set =>
$SET<java.net.URI> $set = $init$;
;;

"URLs used as keys in collections can cause performance problems, since equals() and hashCode() trigger blocking domain lookup operations. Try using java.net.URI instead.":
$set.add($key) :: $set instanceof java.util.Set<java.net.URL> && $key instanceof java.net.URL =>
$set.add($key.toURI())
;;

// map + URL
"URLs used as keys in collections can cause performance problems, since equals() and hashCode() trigger blocking domain lookup operations. Try using java.net.URI instead.":
new $MAP<java.net.URL, $V>($args$) :: $MAP instanceof java.util.Map =>
new $MAP<java.net.URI, $V>($args$)
;;

"URLs used as keys in collections can cause performance problems, since equals() and hashCode() trigger blocking domain lookup operations. Try using java.net.URI instead.":
$MAP<java.net.URL, $V> $map = $init$; :: $MAP instanceof java.util.Map =>
$MAP<java.net.URI, $V> $map = $init$;
;;

"URLs used as keys in collections can cause performance problems, since equals() and hashCode() trigger blocking domain lookup operations. Try using java.net.URI instead.":
$map.put($key, $value) :: $map instanceof java.util.Map<java.net.URL, ?> && $key instanceof java.net.URL =>
$map.put($key.toURI(), $value)
;;

// <19
"suboptimal capacity computation":
new $Col<$T$>($cap) :: sourceVersionLE(18) && $cap instanceof int
                    && matchesAny($Col, "java.util.HashMap", "java.util.LinkedHashMap", "java.util.HashSet", "java.util.LinkedHashSet", "java.util.WeakHashMap")
                    && !matchesAny($cap, "(int) Math.ceil($n / 0.75)")
                    && !isIntLiteral($cap)
=> new $Col<$T$>((int) Math.ceil($n / 0.75)) :: matchesWithBind($cap, "(int) Math.ceil($n / 0.75f)")
=> new $Col<$T$>((int) Math.ceil($n / 0.75)) :: matchesWithBind($cap, "(int) ($n / $fac)") && matchesAny($fac, "0.75", "0.75f")
=> new $Col<$T$>((int) Math.ceil($n / 0.75)) :: matchesWithBind($cap, "(int) ($n / $fac) + $one") && matchesAny($fac, "0.75", "0.75f") && matchesAny($one, "1", "1.0", "1.0f")
=> new $Col<$T$>((int) Math.ceil($n / 0.75)) :: matchesWithBind($cap, "(int) ($n / $fac + $one)") && matchesAny($fac, "0.75", "0.75f") && matchesAny($one, "1", "1.0", "1.0f")
=> new $Col<$T$>((int) Math.ceil($n / 0.75)) :: matchesWithBind($cap, "($n * 4 + 2) / 3")
=> new $Col<$T$>((int) Math.ceil($n / 0.75)) :: matchesWithBind($cap, "(4 * $n + 2) / 3")
=> new $Col<$T$>((int) Math.ceil($n / 0.75)) :: matchesWithBind($cap, "($n * 4) / 3 + 1")
=> new $Col<$T$>((int) Math.ceil($n / 0.75)) :: matchesWithBind($cap, "($n * 4) / 3")
=> new $Col<$T$>((int) Math.ceil($n / 0.75)) :: matchesWithBind($cap, "(4 * $n) / 3 + 1")
=> new $Col<$T$>((int) Math.ceil($n / 0.75)) :: matchesWithBind($cap, "(4 * $n) / 3")
=> new $Col<$T$>((int) Math.ceil($n / 0.75)) :: matchesWithBind($cap, "$n * 4 / 3 + 1")
=> new $Col<$T$>((int) Math.ceil($n / 0.75)) :: matchesWithBind($cap, "$n * 4 / 3")
=> new $Col<$T$>((int) Math.ceil($n / 0.75)) :: matchesWithBind($cap, "4 * $n / 3 + 1")
=> new $Col<$T$>((int) Math.ceil($n / 0.75)) :: matchesWithBind($cap, "4 * $n / 3")
=> new $Col<$T$>((int) Math.ceil($n / 0.75)) :: matchesWithBind($cap, "(int) (($n * 4L + 2L) / 3L)")
=> new $Col<$T$>((int) Math.ceil($n / 0.75)) :: matchesWithBind($cap, "(int) ((4L * $n + 2L) / 3L)")
=> new $Col<$T$>((int) Math.ceil($cap / 0.75)) :: otherwise
;;

// 19+ Map/Set factory methods
"convert to factory method for creating pre-sized Maps using initial number of entries instead of table capacity.":
new java.util.HashMap<$T$>($cap) :: $cap instanceof int && sourceVersionGE(19)
=> java.util.HashMap.newHashMap($n) :: matchesWithBind($cap, "(int) Math.ceil($n / $fac)") && matchesAny($fac, "0.75", "0.75f")
=> java.util.HashMap.newHashMap($n) :: matchesWithBind($cap, "(int) ($n / $fac)") && matchesAny($fac, "0.75", "0.75f")
=> java.util.HashMap.newHashMap($n) :: matchesWithBind($cap, "(int) ($n / $fac) + $one") && matchesAny($fac, "0.75", "0.75f") && matchesAny($one, "1", "1.0", "1.0f")
=> java.util.HashMap.newHashMap($n) :: matchesWithBind($cap, "(int) ($n / $fac + $one)") && matchesAny($fac, "0.75", "0.75f") && matchesAny($one, "1", "1.0", "1.0f")
=> java.util.HashMap.newHashMap($n) :: matchesWithBind($cap, "($n * 4 + 2) / 3")
=> java.util.HashMap.newHashMap($n) :: matchesWithBind($cap, "(4 * $n + 2) / 3")
=> java.util.HashMap.newHashMap($n) :: matchesWithBind($cap, "($n * 4) / 3 + 1")
=> java.util.HashMap.newHashMap($n) :: matchesWithBind($cap, "($n * 4) / 3")
=> java.util.HashMap.newHashMap($n) :: matchesWithBind($cap, "(4 * $n) / 3 + 1")
=> java.util.HashMap.newHashMap($n) :: matchesWithBind($cap, "(4 * $n) / 3")
=> java.util.HashMap.newHashMap($n) :: matchesWithBind($cap, "$n * 4 / 3 + 1")
=> java.util.HashMap.newHashMap($n) :: matchesWithBind($cap, "$n * 4 / 3")
=> java.util.HashMap.newHashMap($n) :: matchesWithBind($cap, "4 * $n / 3 + 1")
=> java.util.HashMap.newHashMap($n) :: matchesWithBind($cap, "4 * $n / 3")
=> java.util.HashMap.newHashMap($n) :: matchesWithBind($cap, "(int) (($n * 4L + 2L) / 3L)")
=> java.util.HashMap.newHashMap($n) :: matchesWithBind($cap, "(int) ((4L * $n + 2L) / 3L)")
=> java.util.HashMap.newHashMap($cap) :: otherwise
;;

"convert to factory method for creating pre-sized Maps using initial number of entries instead of table capacity.":
new java.util.LinkedHashMap<$T$>($cap) :: $cap instanceof int && sourceVersionGE(19)
=> java.util.LinkedHashMap.newLinkedHashMap($n) :: matchesWithBind($cap, "(int) Math.ceil($n / $fac)") && matchesAny($fac, "0.75", "0.75f")
=> java.util.LinkedHashMap.newLinkedHashMap($n) :: matchesWithBind($cap, "(int) ($n / $fac)") && matchesAny($fac, "0.75", "0.75f")
=> java.util.LinkedHashMap.newLinkedHashMap($n) :: matchesWithBind($cap, "(int) ($n / $fac + $one)") && matchesAny($fac, "0.75", "0.75f") && matchesAny($one, "1", "1.0", "1.0f")
=> java.util.LinkedHashMap.newLinkedHashMap($n) :: matchesWithBind($cap, "(int) ($n / $fac + $one)") && matchesAny($fac, "0.75", "0.75f") && matchesAny($one, "1", "1.0", "1.0f")
=> java.util.LinkedHashMap.newLinkedHashMap($n) :: matchesWithBind($cap, "($n * 4 + 2) / 3")
=> java.util.LinkedHashMap.newLinkedHashMap($n) :: matchesWithBind($cap, "(4 * $n + 2) / 3")
=> java.util.LinkedHashMap.newLinkedHashMap($n) :: matchesWithBind($cap, "($n * 4) / 3 + 1")
=> java.util.LinkedHashMap.newLinkedHashMap($n) :: matchesWithBind($cap, "($n * 4) / 3")
=> java.util.LinkedHashMap.newLinkedHashMap($n) :: matchesWithBind($cap, "(4 * $n) / 3 + 1")
=> java.util.LinkedHashMap.newLinkedHashMap($n) :: matchesWithBind($cap, "(4 * $n) / 3")
=> java.util.LinkedHashMap.newLinkedHashMap($n) :: matchesWithBind($cap, "$n * 4 / 3 + 1")
=> java.util.LinkedHashMap.newLinkedHashMap($n) :: matchesWithBind($cap, "$n * 4 / 3")
=> java.util.LinkedHashMap.newLinkedHashMap($n) :: matchesWithBind($cap, "4 * $n / 3 + 1")
=> java.util.LinkedHashMap.newLinkedHashMap($n) :: matchesWithBind($cap, "4 * $n / 3")
=> java.util.LinkedHashMap.newLinkedHashMap($n) :: matchesWithBind($cap, "(int) (($n * 4L + 2L) / 3L)")
=> java.util.LinkedHashMap.newLinkedHashMap($n) :: matchesWithBind($cap, "(int) ((4L * $n + 2L) / 3L)")
=> java.util.LinkedHashMap.newLinkedHashMap($cap) :: otherwise
;;

"convert to factory method for creating pre-sized Maps using initial number of entries instead of table capacity.":
new java.util.WeakHashMap<$T$>($cap) :: $cap instanceof int && sourceVersionGE(19)
=> java.util.WeakHashMap.newWeakHashMap($n) :: matchesWithBind($cap, "(int) Math.ceil($n / $fac)") && matchesAny($fac, "0.75", "0.75f")
=> java.util.WeakHashMap.newWeakHashMap($n) :: matchesWithBind($cap, "(int) ($n / $fac)") && matchesAny($fac, "0.75", "0.75f")
=> java.util.WeakHashMap.newWeakHashMap($n) :: matchesWithBind($cap, "(int) ($n / $fac + $one)") && matchesAny($fac, "0.75", "0.75f") && matchesAny($one, "1", "1.0", "1.0f")
=> java.util.WeakHashMap.newWeakHashMap($n) :: matchesWithBind($cap, "(int) ($n / $fac + $one)") && matchesAny($fac, "0.75", "0.75f") && matchesAny($one, "1", "1.0", "1.0f")
=> java.util.WeakHashMap.newWeakHashMap($n) :: matchesWithBind($cap, "($n * 4 + 2) / 3")
=> java.util.WeakHashMap.newWeakHashMap($n) :: matchesWithBind($cap, "(4 * $n + 2) / 3")
=> java.util.WeakHashMap.newWeakHashMap($n) :: matchesWithBind($cap, "($n * 4) / 3 + 1")
=> java.util.WeakHashMap.newWeakHashMap($n) :: matchesWithBind($cap, "($n * 4) / 3")
=> java.util.WeakHashMap.newWeakHashMap($n) :: matchesWithBind($cap, "(4 * $n) / 3 + 1")
=> java.util.WeakHashMap.newWeakHashMap($n) :: matchesWithBind($cap, "(4 * $n) / 3")
=> java.util.WeakHashMap.newWeakHashMap($n) :: matchesWithBind($cap, "$n * 4 / 3 + 1")
=> java.util.WeakHashMap.newWeakHashMap($n) :: matchesWithBind($cap, "$n * 4 / 3")
=> java.util.WeakHashMap.newWeakHashMap($n) :: matchesWithBind($cap, "4 * $n / 3 + 1")
=> java.util.WeakHashMap.newWeakHashMap($n) :: matchesWithBind($cap, "4 * $n / 3")
=> java.util.WeakHashMap.newWeakHashMap($n) :: matchesWithBind($cap, "(int) (($n * 4L + 2L) / 3L)")
=> java.util.WeakHashMap.newWeakHashMap($n) :: matchesWithBind($cap, "(int) ((4L * $n + 2L) / 3L)")
=> java.util.WeakHashMap.newWeakHashMap($cap) :: otherwise
;;

"convert to factory method for creating pre-sized Sets using initial number of entries instead of table capacity.":
new java.util.HashSet<$T$>($cap) :: $cap instanceof int && sourceVersionGE(19)
=> java.util.HashSet.newHashSet($n) :: matchesWithBind($cap, "(int) Math.ceil($n / $fac)") && matchesAny($fac, "0.75", "0.75f")
=> java.util.HashSet.newHashSet($n) :: matchesWithBind($cap, "(int) ($n / $fac)") && matchesAny($fac, "0.75", "0.75f")
=> java.util.HashSet.newHashSet($n) :: matchesWithBind($cap, "(int) ($n / $fac + $one)") && matchesAny($fac, "0.75", "0.75f") && matchesAny($one, "1", "1.0", "1.0f")
=> java.util.HashSet.newHashSet($n) :: matchesWithBind($cap, "(int) ($n / $fac + $one)") && matchesAny($fac, "0.75", "0.75f") && matchesAny($one, "1", "1.0", "1.0f")
=> java.util.HashSet.newHashSet($n) :: matchesWithBind($cap, "($n * 4 + 2) / 3")
=> java.util.HashSet.newHashSet($n) :: matchesWithBind($cap, "(4 * $n + 2) / 3")
=> java.util.HashSet.newHashSet($n) :: matchesWithBind($cap, "($n * 4) / 3 + 1")
=> java.util.HashSet.newHashSet($n) :: matchesWithBind($cap, "($n * 4) / 3")
=> java.util.HashSet.newHashSet($n) :: matchesWithBind($cap, "(4 * $n) / 3 + 1")
=> java.util.HashSet.newHashSet($n) :: matchesWithBind($cap, "(4 * $n) / 3")
=> java.util.HashSet.newHashSet($n) :: matchesWithBind($cap, "$n * 4 / 3 + 1")
=> java.util.HashSet.newHashSet($n) :: matchesWithBind($cap, "$n * 4 / 3")
=> java.util.HashSet.newHashSet($n) :: matchesWithBind($cap, "4 * $n / 3 + 1")
=> java.util.HashSet.newHashSet($n) :: matchesWithBind($cap, "4 * $n / 3")
=> java.util.HashSet.newHashSet($n) :: matchesWithBind($cap, "(int) (($n * 4L + 2L) / 3L)")
=> java.util.HashSet.newHashSet($n) :: matchesWithBind($cap, "(int) ((4L * $n + 2L) / 3L)")
=> java.util.HashSet.newHashSet($cap) :: otherwise
;;

"convert to factory method for creating pre-sized Sets using initial number of entries instead of table capacity.":
new java.util.LinkedHashSet<$T$>($cap) :: $cap instanceof int && sourceVersionGE(19)
=> java.util.LinkedHashSet.newLinkedHashSet($n) :: matchesWithBind($cap, "(int) Math.ceil($n / $fac)") && matchesAny($fac, "0.75", "0.75f")
=> java.util.LinkedHashSet.newLinkedHashSet($n) :: matchesWithBind($cap, "(int) ($n / $fac)") && matchesAny($fac, "0.75", "0.75f")
=> java.util.LinkedHashSet.newLinkedHashSet($n) :: matchesWithBind($cap, "(int) ($n / $fac + $one)") && matchesAny($fac, "0.75", "0.75f") && matchesAny($one, "1", "1.0", "1.0f")
=> java.util.LinkedHashSet.newLinkedHashSet($n) :: matchesWithBind($cap, "(int) ($n / $fac + $one)") && matchesAny($fac, "0.75", "0.75f") && matchesAny($one, "1", "1.0", "1.0f")
=> java.util.LinkedHashSet.newLinkedHashSet($n) :: matchesWithBind($cap, "($n * 4 + 2) / 3")
=> java.util.LinkedHashSet.newLinkedHashSet($n) :: matchesWithBind($cap, "(4 * $n + 2) / 3")
=> java.util.LinkedHashSet.newLinkedHashSet($n) :: matchesWithBind($cap, "($n * 4) / 3 + 1")
=> java.util.LinkedHashSet.newLinkedHashSet($n) :: matchesWithBind($cap, "($n * 4) / 3")
=> java.util.LinkedHashSet.newLinkedHashSet($n) :: matchesWithBind($cap, "(4 * $n) / 3 + 1")
=> java.util.LinkedHashSet.newLinkedHashSet($n) :: matchesWithBind($cap, "(4 * $n) / 3")
=> java.util.LinkedHashSet.newLinkedHashSet($n) :: matchesWithBind($cap, "$n * 4 / 3 + 1")
=> java.util.LinkedHashSet.newLinkedHashSet($n) :: matchesWithBind($cap, "$n * 4 / 3")
=> java.util.LinkedHashSet.newLinkedHashSet($n) :: matchesWithBind($cap, "4 * $n / 3 + 1")
=> java.util.LinkedHashSet.newLinkedHashSet($n) :: matchesWithBind($cap, "4 * $n / 3")
=> java.util.LinkedHashSet.newLinkedHashSet($n) :: matchesWithBind($cap, "(int) (($n * 4L + 2L) / 3L)")
=> java.util.LinkedHashSet.newLinkedHashSet($n) :: matchesWithBind($cap, "(int) ((4L * $n + 2L) / 3L)")
=> java.util.LinkedHashSet.newLinkedHashSet($cap) :: otherwise
;;


<?
    public boolean isEmpty(Variable var) throws Throwable {
        return !context.getIndexedVariables(var).iterator().hasNext();
    }

    public boolean isIntLiteral(Variable var) throws Throwable {
        TreePath tp = APIAccessor.IMPL.getSingleVariable(context, var);
        return tp != null && tp.getLeaf().getKind() == Kind.INT_LITERAL;
    }
?>

